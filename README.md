# Gobang
原生js + canvas实现的五子棋

预览地址：[118.24.24.30](118.24.24.30)

### 代码结构
1. EventTarget是一个简单的事件系统，后面的代码依赖此模块
![](http://ww1.sinaimg.cn/mw690/8922edaegy1fq32s3yhnjj20h50h4abe.jpg)

2. Dialog是一个模态框，用于刚开始进入游戏时选择玩家对战或者人机对战的游戏模式，和游戏提示。
![](http://ww1.sinaimg.cn/mw690/8922edaegy1fq32tyfl7ej20n60hajtd.jpg)

3. 接着是游戏的全局变量声明，游戏模式，玩家设置，悔棋，撤销悔棋状态栈等都在此声明。
![](http://ww1.sinaimg.cn/mw690/8922edaegy1fq32v92frij20e30beq3n.jpg)

4. PLAY命名空间下的是游戏逻辑部分，UI命名空间下的是视图部分，两者皆原型继承自EventTarget(事件系统)，通过事件进行通讯，从而实现视图和逻辑之间的解耦。
![](http://ww1.sinaimg.cn/large/8922edaegy1fq32wdw3bcj20jm0fxjtf.jpg)
![](http://ww1.sinaimg.cn/large/8922edaegy1fq32x06avqj20g60eb0tu.jpg)

5. 接着是整个游戏的入口，接受一个dom节点容器，进行游戏的初始化
![](http://ww1.sinaimg.cn/large/8922edaegy1fq32xo0ppvj20fi0h2jsh.jpg)

6. 最后是当页面加载完成后进行游戏初始化
![](http://ww1.sinaimg.cn/large/8922edaegy1fq32yxnqp2j20fs02tglk.jpg)

### 游戏逻辑
1. 下棋

代码中有一个全局变量STATE，是一个二维数组，它是五子棋落棋点和当前落棋状态的映射。假设是5 * 5的棋盘，则STATE数组如下：

![](http://ww1.sinaimg.cn/mw690/8922edaegy1fq349zmzumj20c703rmwz.jpg)

当玩家1 在其中一个点落棋，则把该点的 0 改为 1 ；玩家2 在其中一点落棋，则把该点的 0 改为 2。

在修改之前，还要先判断该点是否为 0 ，如果不为 0 ，则说明此前已经有棋子了，已经下过棋子的位置不能重复下棋。

2. 胜负判断

由于要判断胜负，因此在每次下棋之后，还要一个算法判断，当前有没有已经连成五个棋子？算法是PLAY.checkEnding方法。

![](http://ww1.sinaimg.cn/mw690/8922edaegy1fq3331kst4j20qy0gsacj.jpg)

简单介绍一下这个逻辑：五子棋的胜利是当一方的连续棋子数达到五个，中间没有被分隔，即胜利。所以胜利的情况有四种，呈'米'字型的一半，分别是水平连成五个，垂直连成五个，左上方到右下方连成五个，右上方到左下方连成五个。

如果我们从第一行第一个，即STATE[0][0]开始，遍历这个二维数组。则我们只需要判断从当前的STATE[x][y]开始，向左x+1,x+2...x+4；向下y+1,y+2...y+4；向右下x+1,y+1，向左下x-1,y+1 这四个方向。是否有和STATE[x][y]相等(为1或者2)的棋子，并且达到连续五个，我们就可以肯定当前已经游戏结束。

3. 和电脑对战

首先，需要明确玩五子棋就是要防止对方连成5个和使自己连成五个。所以，连续的棋子数越多，离游戏结束就越近了。

算法分为两部分，计算当前棋局状态下的权重数组(对应STATE上的每个点)，和计算出权重最大的落棋点。PLAY.calcArr和PLAY.searchMaxWeight，如图：

![](http://ww1.sinaimg.cn/mw690/8922edaegy1fq33n55m25j20n40cj0u1.jpg)

简单介绍一下这个逻辑：计算权重和判断胜负不一样，因为判断胜负是从左上角的点开始，所以一旦判断出胜利，该点一定是连续五个的第一个。而计算权重需要计算的方向呈'米'字型，所以每个点要遍历八个方向。

特别地：因为连续的棋子数越多，情况就越紧急，例如点 x 向左和向右方向上都有两个棋子，点 y 向左方向上有三个棋子，此时点 y 的权重应要较大。

![](http://ww1.sinaimg.cn/mw690/8922edaegy1fq33z2794gj20m505sdgk.jpg)

如上图：在遍历各个方向时，一开始初始化权重continus为1，当有一个连续棋子后就*10=10，如果再有一个连续棋子则再*10=100，这样改变权重系数。经过我的实验，效果最好。


### 其它方面

例如计算棋盘每个格子对应的坐标，绘制棋子等等UI相关的都在UI命名空间下，比较简单，而且代码注释也比较丰富，所以不再详述。
